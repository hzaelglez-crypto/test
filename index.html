<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TaktLab – Cycle Time & Capacity Analyzer</title>

<style>
  :root{
    --bg-main:#07152b;
    --bg-card:#0b1f3a;
    --bg-card-soft:#0f2544;

    /* toned-down accents (more pro, less neon) */
    --accent-green:#18c97a;
    --accent-amber:#f2c14e;
    --accent-red:#ff3355;
    --accent-blue:#39bdf5;
    --accent-grey:#cfd8dc;

    --text-main:#ffffff;
    --text-soft:#c5cae9;
    --text-muted:#90a4ae;
    --border-soft:#1c3357;

    --btn-green:#18c97a;
    --btn-orange:#f2a93b;
    --btn-grey:#455a64;

    /* subtler badges */
    --badge-green:rgba(24,201,122,.16);
    --badge-red:rgba(255,51,85,.16);
    --badge-amber:rgba(242,193,78,.16);

    /* WB sticky sizing (Seq removed) */
    --wb-on-w:56px;
    --wb-op-w:210px;
  }

  *{box-sizing:border-box;}

  body{
    margin:0;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 40%,#020b1a 100%);
    color:var(--text-main);
  }

  .page{
    max-width:1100px;
    margin:0 auto;
    padding:10px 10px 34px;
  }

  .sticky-timer-bar{
    position:sticky;
    top:0;
    z-index:100;
    background:linear-gradient(180deg,#020b1a 0%,#07152b 90%);
    padding:6px 0 8px;
  }

  .top-row{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:6px;
  }

  .logo-circle{
    width:38px;height:38px;border-radius:50%;
    border:2px solid rgba(207,216,220,.65);
    display:flex;align-items:center;justify-content:center;
  }
  .logo-gear{
    width:22px;height:22px;border-radius:50%;
    border:2px solid rgba(207,216,220,.65);
    position:relative;
  }
  .logo-gear::before{
    content:"";
    position:absolute;
    inset:4px;
    border-radius:50%;
    border:2px solid rgba(24,201,122,.9);
    border-right-color:transparent;
    border-bottom-color:transparent;
    transform-origin:50% 50%;
  }
  .logo-gear.spinning::before{ animation:logo-spin 2s linear infinite; }
  @keyframes logo-spin{ from{transform:rotate(0deg);} to{transform:rotate(360deg);} }

  .title-block{display:flex;flex-direction:column;gap:2px;}
  .title-main{font-size:1.2rem;font-weight:700;letter-spacing:.03em;}
  .title-sub{font-size:.72rem;color:var(--text-soft);}

  .lang-switch{margin-left:auto;display:flex;align-items:center;gap:4px;}
  .lang-btn{
    border-radius:999px;border:1px solid var(--border-soft);
    background:rgba(2,11,26,.6);color:var(--text-soft);
    font-size:.7rem;padding:4px 8px;cursor:pointer;min-width:34px;
  }
  .lang-btn.active{background:rgba(57,189,245,.95);color:#fff;border-color:rgba(57,189,245,.95);font-weight:700;}

  .timer-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid var(--border-soft);
    padding:6px 10px 10px;
    box-shadow:0 8px 18px rgba(0,0,0,.45);
  }

  .timer-display{
    text-align:center;
    font-size:2.8rem;
    font-weight:600;
    letter-spacing:.08em;
    padding:4px 4px 2px;
  }

  /* ✅ Restored T1/T2 clocks */
  .split-clocks{
    display:flex;
    gap:8px;
    justify-content:center;
    margin:2px 0 8px;
    flex-wrap:wrap;
  }
  .split-pill{
    display:flex;
    align-items:center;
    gap:6px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
    font-size:.78rem;
    color:var(--text-soft);
    min-width:150px;
    justify-content:center;
  }
  .split-pill .tag{
    font-weight:800;
    letter-spacing:.04em;
    color:#fff;
    opacity:.85;
  }
  .split-pill .val{
    font-variant-numeric:tabular-nums;
    letter-spacing:.04em;
    color:#fff;
  }
  .split-pill.t1{ border-color: rgba(57,189,245,.30); }
  .split-pill.t2{ border-color: rgba(242,193,78,.28); }

  .info-stack{ display:flex; flex-direction:column; gap:6px; margin:0 0 8px; }
  .info-line{
    font-size:.78rem;margin:0;padding:6px 10px;
    border-radius:12px;border:1px solid transparent;
    line-height:1.25;
  }
  .sample-neutral{background:rgba(255,255,255,.03);border-color:rgba(255,255,255,.08);color:var(--text-soft);}
  .sample-good{background:rgba(24,201,122,.12);border-color:rgba(24,201,122,.45);color:#d9ffe9;}
  .sample-warn{background:rgba(242,193,78,.10);border-color:rgba(242,193,78,.40);color:#fff4d3;}
  .sample-bad{background:rgba(255,51,85,.10);border-color:rgba(255,51,85,.42);color:#ffd0da;}

  .btn-row-main{display:flex;gap:10px;margin-bottom:2px;}
  .btn{
    border:none;border-radius:16px;padding:10px 12px;
    font-size:.9rem;font-weight:700;cursor:pointer;color:#06101f;
    box-shadow:0 4px 10px rgba(0,0,0,.4);flex:1;
    transition:transform .04s ease, box-shadow .04s ease, background .15s;
    touch-action:manipulation;
  }
  .btn:active{transform:translateY(1px);box-shadow:0 1px 4px rgba(0,0,0,.5);}
  .btn-start{background:rgba(24,201,122,.95); color:#051018;}
  .btn-lap{background:rgba(242,169,59,.95); color:#0b0b0b;}

  .flash{animation:flash-bg .12s ease-out;}
  @keyframes flash-bg{ from{background:rgba(255,255,255,.18);} to{background:transparent;} }

  .content-section{margin-top:8px;}

  /* ✅ Subtle section theming */
  .section-card{
    background:var(--bg-card);
    border-radius:18px;
    border:1px solid rgba(28,51,87,.92);
    padding:8px 10px 10px;
    margin-bottom:10px;
    position:relative;
  }
  .section-card::before{
    content:"";
    position:absolute;
    left:10px; right:10px; top:0;
    height:2px;
    border-radius:999px;
    background:rgba(255,255,255,.06);
  }
  .section-card[data-accent="blue"]::before{ background:rgba(57,189,245,.26); }
  .section-card[data-accent="green"]::before{ background:rgba(24,201,122,.22); }
  .section-card[data-accent="amber"]::before{ background:rgba(242,193,78,.22); }
  .section-card[data-accent="red"]::before{ background:rgba(255,51,85,.20); }
  .section-card[data-accent="grey"]::before{ background:rgba(207,216,220,.18); }

  .section-title{font-size:1.0rem;font-weight:750;margin-bottom:6px;}

  .mode-row{
    display:flex;gap:8px;flex-wrap:wrap;align-items:flex-end;
    font-size:.78rem;color:var(--text-soft);
  }
  .mode-row select,.mode-row input{
    background:#020b1a;border-radius:10px;border:1px solid var(--border-soft);
    padding:5px 10px;color:var(--text-soft);font-size:.78rem;min-width:70px;
  }
  .mode-row input[type="number"]{width:78px;}

  table{width:100%;border-collapse:collapse;font-size:.72rem;}
  th,td{
    padding:3px 5px;text-align:right;
    border-bottom:1px solid rgba(255,255,255,.04);
    white-space:nowrap;
    vertical-align:middle;
  }
  th:first-child,td:first-child{text-align:left;}
  th{
    color:var(--text-soft);font-weight:650;background:rgba(255,255,255,.02);
    position:sticky;top:0;z-index:5;
  }
  tbody tr:nth-child(even){background:rgba(255,255,255,.02);}

  .badge{
    display:inline-block;padding:2px 8px;border-radius:999px;
    font-size:.68rem;border:1px solid rgba(255,255,255,.12);
  }
  .badge-good{background:var(--badge-green);border-color:rgba(24,201,122,.40);color:#d9ffe9;}
  .badge-warn{background:var(--badge-amber);border-color:rgba(242,193,78,.40);color:#fff4d3;}
  .badge-bad{background:var(--badge-red);border-color:rgba(255,51,85,.42);color:#ffd0da;}

  .btn-row-secondary{display:flex;flex-wrap:wrap;gap:10px;margin:8px 0 4px;}
  .btn-small{
    padding:12px 18px;
    border-radius:18px;
    font-size:.95rem;
    font-weight:850;
    flex:0 0 auto;background:var(--bg-card-soft);color:var(--text-soft);
    border:1px solid var(--border-soft);cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,.35);
  }
  .btn-small-copy{background:rgba(57,189,245,.95);border-color:rgba(57,189,245,.95);color:#051018;}
  .btn-small-summary{background:rgba(242,193,78,.95);border-color:rgba(242,193,78,.95);color:#0b0b0b;}
  .btn-small-manual{background:rgba(24,201,122,.95);border-color:rgba(24,201,122,.95);color:#051018;}
  .btn-small-reset{background:rgba(255,51,85,.92);border-color:rgba(255,51,85,.92);color:#fff;}
  .btn-small-wbadd{background:rgba(255,255,255,.06);color:var(--text-soft);}
  .btn-small-wbclear{background:rgba(255,51,85,.12);border-color:rgba(255,51,85,.35);color:#ffd0da;}

  .subsection-title{margin-top:10px;font-size:.82rem;font-weight:700;color:var(--text-soft);}
  .footer-note{margin-top:10px;font-size:.65rem;color:var(--text-muted);text-align:right;}

  .charts-wrapper{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:10px;
  }
  .chart-card{
    background:var(--bg-card-soft);
    border-radius:14px;
    border:1px solid var(--border-soft);
    padding:8px;
  }
  .chart-title{font-size:.75rem;margin-bottom:4px;color:var(--text-soft);}
  canvas{width:100%;height:180px;background:#020b1a;border-radius:10px;}

  .btn-edit,.btn-del,.btn-relink{
    padding:2px 8px;border-radius:10px;font-size:.7rem;
    border:1px solid rgba(255,255,255,.2);cursor:pointer;background:transparent;
  }
  .btn-edit{color:#9fe4ff;}
  .btn-del{color:#ffd0da;}
  .btn-relink{color:#fff4d3;}

  .wb-inp, .wb-sel, .wb-chk{
    background:#020b1a;border-radius:10px;border:1px solid var(--border-soft);
    padding:2px 8px;color:var(--text-soft);font-size:.70rem;
    outline:none;
  }
  .wb-inp{width:72px;}
  .wb-inp.wide{width:160px;}
  .wb-inp.slim{width:56px;}
  .wb-sel{width:110px;}

  /* Operation dropdown like Charts */
  .wb-opwrap{
    display:flex;
    gap:6px;
    align-items:center;
    justify-content:flex-start;
  }
  .wb-opselect{
    width: calc(var(--wb-op-w) - 14px);
    max-width: calc(var(--wb-op-w) - 14px);
    background:#020b1a;
    border-radius:10px;
    border:1px solid var(--border-soft);
    padding:3px 8px;
    color:var(--text-soft);
    font-size:.72rem;
  }
  .wb-opbtn{
    border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.04);
    color:var(--text-soft);
    border-radius:10px;
    padding:2px 8px;
    cursor:pointer;
    font-size:.72rem;
  }
  .wb-opbtn:hover{ background:rgba(255,255,255,.06); }

  .wb-pill{
    display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.03);font-size:.72rem;color:var(--text-soft);
  }
  .wb-alert{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px;}
  .wb-alert .badge{font-size:.72rem;padding:4px 10px;}
  .wb-badge-title{font-size:.72rem;color:var(--text-soft);}
  .wb-mini{font-size:.7rem;color:var(--text-muted);line-height:1.25;margin-top:6px;}
  .wb-sumline{
    display:flex;justify-content:flex-end;gap:10px;align-items:center;
    margin-top:6px;font-size:.72rem;color:var(--text-soft);
  }
  .wb-sumline .badge{font-size:.70rem}

  /* =========================
     ✅ WB STICKY COLUMNS (On, Operation) — Seq removed
     ========================= */
  #wbTable{ border-collapse:separate; border-spacing:0; }
  #wbTable th, #wbTable td{ position:relative; }

  /* widths so offsets are correct */
  #wbTable th:nth-child(1), #wbTable td:nth-child(1){ width:var(--wb-on-w); min-width:var(--wb-on-w); }
  #wbTable th:nth-child(2), #wbTable td:nth-child(2){ width:var(--wb-op-w); min-width:var(--wb-op-w); }

  /* 1st col: On */
  #wbTable th:nth-child(1), #wbTable td:nth-child(1){
    position:sticky; left:0;
    z-index:30;
    background:linear-gradient(180deg, rgba(2,11,26,.98) 0%, rgba(7,21,43,.98) 100%);
  }
  /* 2nd col: Operation */
  #wbTable th:nth-child(2), #wbTable td:nth-child(2){
    position:sticky; left:var(--wb-on-w);
    z-index:30;
    background:linear-gradient(180deg, rgba(2,11,26,.98) 0%, rgba(7,21,43,.98) 100%);
  }

  /* header priority */
  #wbTable thead th:nth-child(1),
  #wbTable thead th:nth-child(2){
    z-index:40;
  }

  @media (max-width:600px){
    .timer-display{font-size:2.2rem;}
    .btn-row-main{gap:6px;}
    .btn{font-size:.9rem;border-radius:14px;}
    canvas{height:160px;}
    th,td{font-size:.70rem;}
    .wb-inp{width:66px;}
    .wb-inp.wide{width:130px;}
    .btn-small{padding:12px 16px;font-size:.92rem;}

    :root{
      --wb-on-w:52px;
      --wb-op-w:190px;
    }
    .wb-opselect{
      width: calc(var(--wb-op-w) - 14px);
      max-width: calc(var(--wb-op-w) - 14px);
    }
  }
</style>
</head>

<body>
<div class="page">

  <div class="sticky-timer-bar">
    <div class="top-row">
      <div class="logo-circle"><div class="logo-gear" id="logoGear"></div></div>
      <div class="title-block">
        <div class="title-main">TaktLab</div>
        <div class="title-sub" data-i18n="title.subtitle">Cycle Time &amp; Capacity Analyzer</div>
      </div>
      <div class="lang-switch">
        <button class="lang-btn" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="es">ES</button>
      </div>
    </div>

    <div class="timer-card" id="timerCard">
      <div class="timer-display" id="display">00:00.00</div>

      <!-- ✅ Restored T1/T2 clocks -->
      <div class="split-clocks" id="splitClocks">
        <div class="split-pill t1"><span class="tag">T1</span><span class="val" id="t1Clock">00:00.00</span></div>
        <div class="split-pill t2"><span class="tag">T2</span><span class="val" id="t2Clock">00:00.00</span></div>
      </div>

      <div class="info-stack">
        <div class="info-line sample-neutral" id="sampleInfoTop">
          No samples yet for current process. Start capturing laps.
        </div>
      </div>

      <div class="btn-row-main">
        <button class="btn btn-start" id="btnStart" data-i18n="btn.start">Start</button>
        <button class="btn btn-lap" id="btnLap" data-i18n="btn.lap">LAP</button>
      </div>
    </div>
  </div>

  <div class="content-section">

    <div class="section-card" data-accent="blue">
      <div class="section-title" data-i18n="section.measurementSetup">Measurement Setup</div>

      <div class="mode-row">
        <div>
          <label for="processName" data-i18n="label.process">Process</label><br/>
          <input id="processName" type="text" placeholder="e.g. Op 30-1" data-i18n-placeholder="label.processPlaceholder"/>
        </div>

        <div>
          <label for="mode" data-i18n="label.mode">Mode</label><br/>
          <select id="mode">
            <option value="CT" data-i18n="mode.ct">Cycle Time (CT)</option>
            <option value="MLD" data-i18n="mode.mld">Machine &amp; Load/Unload</option>
          </select>
        </div>

        <div>
          <label for="efficiency" data-i18n="label.efficiency">Efficiency %</label><br/>
          <input id="efficiency" type="number" value="100" min="0" max="100" step="1"/>
        </div>

        <div>
          <label for="contractPcd" data-i18n="label.contractPcd">Contract Cap (pcs/day)</label><br/>
          <input id="contractPcd" type="number" min="0" max="99999" step="1"/>
        </div>

        <div>
          <label for="hoursPerDay" data-i18n="label.hoursPerDay">Hours / Day</label><br/>
          <input id="hoursPerDay" type="number" value="8" min="1" max="24" step=".5"/>
        </div>

        <div>
          <label for="daysPerWeek" data-i18n="label.daysPerWeek">Days / Week</label><br/>
          <input id="daysPerWeek" type="number" value="5" min="1" max="7"/>
        </div>

        <div>
          <label for="capView" data-i18n="label.capView">Capacity View</label><br/>
          <select id="capView">
            <option value="hour" data-i18n="capView.hour">per Hour</option>
            <option value="day" data-i18n="capView.day">per Day</option>
            <option value="week" data-i18n="capView.week">per Week</option>
          </select>
        </div>
      </div>
    </div>

    <div class="section-card" data-accent="green">
      <div class="section-title" data-i18n="section.contractSummary">Contract vs Capacity Summary</div>

      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="contractSumLine1">—</div>
        <div class="info-line sample-neutral" id="contractSumLine2">—</div>
        <div class="info-line sample-neutral" id="contractSumLine3">—</div>
        <div class="info-line sample-neutral" id="contractSumLine4">—</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 0;">
        <span data-i18n="contract.note">Uses current process + your laps (Median/P10/P90) with the Measurement Setup assumptions.</span>
      </div>
    </div>

    <div class="section-card" data-accent="amber">
      <div class="section-title" data-i18n="section.statsFocus">Stat Focus</div>

      <div class="info-stack" style="margin-top:4px;">
        <div class="info-line sample-neutral" id="sampleInfoFocus">Sample size: —</div>
        <div class="info-line sample-neutral" id="stdInfoFocus">Std dev: —</div>
        <div class="info-line sample-neutral" id="distInfoFocus">Mean vs Median: —</div>
        <div class="info-line sample-neutral" id="contractInfoFocus">No contract loaded</div>
      </div>

      <div style="font-size:.68rem;color:var(--text-muted);margin:6px 0 6px;">
        <span data-i18n="stats.note">Simple language on purpose: few / enough samples, low / high variation, capable / not capable.</span>
      </div>

      <div style="max-height:300px;overflow:auto;">
        <table>
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th>N</th>
              <th data-i18n="col.sample">Sample size / Error</th>
              <th>Std</th>
              <th>CV%</th>
              <th>CTmed</th>
              <th>P10</th>
              <th>P90</th>
              <th data-i18n="col.capCurrent">Current @Eff</th>
              <th data-i18n="col.capPotential">Potential @Eff</th>
              <th data-i18n="col.capWorst">Worst @Eff</th>
              <th data-i18n="col.contract">Contract</th>
              <th data-i18n="col.gap">Gap</th>
              <th data-i18n="col.vsContract">% vs</th>
              <th>Cp</th>
              <th>Cpk</th>
              <th data-i18n="col.note">Note</th>
            </tr>
          </thead>
          <tbody id="focusBody"></tbody>
        </table>
      </div>

      <div class="subsection-title" data-i18n="section.wbPlanner">WB – Capacity Planner (by process)</div>

      <div class="btn-row-secondary" style="margin-top:8px;">
        <button class="btn-small btn-small-wbadd" id="btnWbAdd" data-i18n="btn.wbAdd">+ Add Operation</button>
        <button class="btn-small btn-small-wbclear" id="btnWbClear" data-i18n="btn.wbClear">Clear WB</button>
      </div>

      <div style="max-height:320px;overflow:auto;">
        <table id="wbTable">
          <thead>
            <tr>
              <th data-i18n="wb.enabled">On</th>
              <th data-i18n="wb.operation">Operation</th>
              <th data-i18n="wb.operators">Operators</th>
              <th data-i18n="wb.shifts">Shifts</th>
              <th data-i18n="wb.hours">Hours</th>
              <th data-i18n="wb.machines"># Machines</th>
              <th data-i18n="wb.contract">Contract (pcs/day)</th>

              <th data-i18n="wb.gross">Gross min/day</th>
              <th data-i18n="wb.lunch">Lunch min/day</th>
              <th data-i18n="wb.changeover">Changeover</th>
              <th data-i18n="wb.cleaning">5S/Clean</th>
              <th data-i18n="wb.maint">Maintenance</th>
              <th data-i18n="wb.other">Other</th>

              <th data-i18n="wb.shared">Shared Capacity</th>

              <th data-i18n="wb.udt">Unplanned DT</th>
              <th data-i18n="wb.udtUnit">Unit</th>

              <th data-i18n="wb.net">Net min/day</th>

              <th data-i18n="wb.scrap">Scrap %</th>
              <th data-i18n="wb.yield">Yield</th>

              <th data-i18n="wb.oeeA">A%</th>
              <th data-i18n="wb.oeeP">P%</th>
              <th data-i18n="wb.oeeQ">Q%</th>
              <th data-i18n="wb.oee">OEE%</th>

              <th data-i18n="wb.ctCur">CT Current</th>
              <th data-i18n="wb.ctWst">CT Worst</th>
              <th data-i18n="wb.ctPot">CT Potential</th>

              <th data-i18n="wb.ctCurOee">CT@OEE (Cur)</th>

              <th data-i18n="wb.cap100">Cap 100% (Cur)</th>
              <th data-i18n="wb.capOee">Cap@OEE (Cur)</th>

              <th data-i18n="wb.vsContract">% vs contract</th>
              <th data-i18n="wb.inputReq">Input req. for Contract</th>

              <th data-i18n="wb.actions">Actions</th>
            </tr>
          </thead>
          <tbody id="wbBody"></tbody>
        </table>
      </div>

      <div class="wb-sumline">
        <span data-i18n="wb.opsSum">Operators total:</span>
        <span class="badge badge-warn" id="wbOperatorsSum">0</span>
      </div>

      <div class="wb-alert">
        <span class="wb-badge-title" data-i18n="wb.constraintTitle">Constraint / Next:</span>
        <span class="badge badge-bad" id="wbConstraint">—</span>
        <span class="badge badge-warn" id="wbNextConstraint">—</span>
      </div>
      <div class="wb-mini" id="wbConstraintNote"></div>

      <div class="subsection-title" data-i18n="section.statsDetail">Statistical Detail (per process)</div>
      <div style="max-height:240px;overflow:auto;">
        <table id="statsTable">
          <thead>
            <tr>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.n">N</th>
              <th>Mean</th>
              <th>Median</th>
              <th>P10</th>
              <th>P90</th>
              <th>Min</th>
              <th>Max</th>
              <th>Std</th>
              <th>CV%</th>
              <th>Cp</th>
              <th>Cpk</th>
            </tr>
          </thead>
          <tbody id="statsBody"></tbody>
        </table>
      </div>
    </div>

    <div class="section-card" data-accent="red">
      <div class="section-title" data-i18n="section.dataControls">Data Controls</div>
      <div class="btn-row-secondary">
        <button class="btn-small btn-small-copy" id="btnCopyAll" data-i18n="btn.copyAll">Copy All</button>
        <button class="btn-small btn-small-summary" id="btnCopySummary" data-i18n="btn.copySummary">Copy Summary</button>
        <button class="btn-small btn-small-manual" id="btnAddManualLap" data-i18n="btn.addManualLap">Add Manual Lap</button>
        <button class="btn-small btn-small-reset" id="btnReset" data-i18n="btn.reset">Reset</button>
      </div>
    </div>

    <div class="section-card" data-accent="grey">
      <div class="section-title" data-i18n="section.charts">Charts (selected process)</div>

      <div style="margin-bottom:6px;font-size:.75rem;">
        <label for="chartProcessSelect" data-i18n="label.chartProcessLabel">Process / Mode:</label>
        <select id="chartProcessSelect"></select>
      </div>

      <div class="charts-wrapper">
        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.timeSeriesTitle">Time Series with Mean, Median, ±3σ</div>
          <canvas id="timeSeriesCanvas"></canvas>
        </div>

        <div class="chart-card">
          <div class="chart-title" data-i18n="chart.histTitle">Histogram with Median &amp; Percentiles</div>
          <canvas id="histCanvas"></canvas>
        </div>
      </div>
    </div>

    <div class="section-card" data-accent="blue">
      <div class="section-title" data-i18n="section.rawData">Raw Time Data</div>
      <div style="max-height:300px;overflow:auto;">
        <table id="dataTable">
          <thead>
            <tr>
              <th data-i18n="col.index">#</th>
              <th data-i18n="col.process">Process</th>
              <th data-i18n="col.mode">Mode</th>
              <th data-i18n="col.status">Status</th>
              <th data-i18n="col.note">Note</th>
              <th data-i18n="col.t1">T1 (s)</th>
              <th data-i18n="col.t2">T2 (s)</th>
              <th data-i18n="col.total">Total (s)</th>
              <th data-i18n="col.edit">Edit</th>
              <th data-i18n="col.del">Del</th>
            </tr>
          </thead>
          <tbody id="dataBody"></tbody>
        </table>
      </div>
    </div>

    <div class="section-card" data-accent="amber">
      <div class="section-title" data-i18n="section.methodGuide">Method &amp; Guide</div>
      <details style="background:var(--bg-card-soft);border:1px solid var(--border-soft);border-radius:14px;padding:10px;">
        <summary style="cursor:pointer;color:var(--text-soft);font-weight:800;">
          <span data-i18n="method.open">Open</span>
        </summary>
        <div style="margin-top:8px;font-size:.72rem;color:var(--text-soft);line-height:1.35;white-space:pre-wrap;" id="methodGuideText"></div>
      </details>
    </div>

  </div>

  <div class="footer-note" data-i18n="footer.note">
    Created by Roberto González – Contact: hzaelglez@gmail.com
  </div>
</div>

<!-- ✅ PARTE 2 empieza exactamente en la siguiente línea: <script> -->
<script>
/* =========================
   TaktLab – Part 2 (JS)
   ========================= */

(() => {
  "use strict";

  /* ---------- DOM ---------- */
  const $ = (id) => document.getElementById(id);

  const el = {
    logoGear: $("logoGear"),
    timerCard: $("timerCard"),
    display: $("display"),
    t1Clock: $("t1Clock"),
    t2Clock: $("t2Clock"),
    btnStart: $("btnStart"),
    btnLap: $("btnLap"),

    processName: $("processName"),
    mode: $("mode"),
    efficiency: $("efficiency"),
    contractPcd: $("contractPcd"),
    hoursPerDay: $("hoursPerDay"),
    daysPerWeek: $("daysPerWeek"),
    capView: $("capView"),

    sampleInfoTop: $("sampleInfoTop"),

    contractSumLine1: $("contractSumLine1"),
    contractSumLine2: $("contractSumLine2"),
    contractSumLine3: $("contractSumLine3"),
    contractSumLine4: $("contractSumLine4"),

    sampleInfoFocus: $("sampleInfoFocus"),
    stdInfoFocus: $("stdInfoFocus"),
    distInfoFocus: $("distInfoFocus"),
    contractInfoFocus: $("contractInfoFocus"),
    focusBody: $("focusBody"),

    btnCopyAll: $("btnCopyAll"),
    btnCopySummary: $("btnCopySummary"),
    btnAddManualLap: $("btnAddManualLap"),
    btnReset: $("btnReset"),

    chartProcessSelect: $("chartProcessSelect"),
    timeSeriesCanvas: $("timeSeriesCanvas"),
    histCanvas: $("histCanvas"),

    dataBody: $("dataBody"),
    statsBody: $("statsBody"),

    btnWbAdd: $("btnWbAdd"),
    btnWbClear: $("btnWbClear"),
    wbBody: $("wbBody"),
    wbOperatorsSum: $("wbOperatorsSum"),
    wbConstraint: $("wbConstraint"),
    wbNextConstraint: $("wbNextConstraint"),
    wbConstraintNote: $("wbConstraintNote"),

    methodGuideText: $("methodGuideText")
  };

  /* ---------- i18n ---------- */
  const I18N = {
    en: {
      "title.subtitle": "Cycle Time & Capacity Analyzer",
      "btn.start": "Start",
      "btn.lap": "LAP",
      "section.measurementSetup": "Measurement Setup",
      "label.process": "Process",
      "label.processPlaceholder": "e.g. Op 30-1",
      "label.mode": "Mode",
      "mode.ct": "Cycle Time (CT)",
      "mode.mld": "Machine & Load/Unload",
      "label.efficiency": "Efficiency %",
      "label.contractPcd": "Contract Cap (pcs/day)",
      "label.hoursPerDay": "Hours / Day",
      "label.daysPerWeek": "Days / Week",
      "label.capView": "Capacity View",
      "capView.hour": "per Hour",
      "capView.day": "per Day",
      "capView.week": "per Week",
      "section.contractSummary": "Contract vs Capacity Summary",
      "contract.note": "Uses current process + your laps (Median/P10/P90) with the Measurement Setup assumptions.",
      "section.statsFocus": "Stat Focus",
      "stats.note": "Simple language on purpose: few / enough samples, low / high variation, capable / not capable.",
      "col.process": "Process",
      "col.mode": "Mode",
      "col.n": "N",
      "col.sample": "Sample size / Error",
      "col.capCurrent": "Current @Eff",
      "col.capPotential": "Potential @Eff",
      "col.capWorst": "Worst @Eff",
      "col.contract": "Contract",
      "col.gap": "Gap",
      "col.note": "Note",
      "section.wbPlanner": "WB – Capacity Planner (by process)",
      "btn.wbAdd": "+ Add Operation",
      "btn.wbClear": "Clear WB",
      "wb.enabled": "On",
      "wb.operation": "Operation",
      "wb.operators": "Operators",
      "wb.shifts": "Shifts",
      "wb.hours": "Hours",
      "wb.machines": "# Machines",
      "wb.contract": "Contract (pcs/day)",
      "wb.gross": "Gross min/day",
      "wb.lunch": "Lunch min/day",
      "wb.changeover": "Changeover",
      "wb.cleaning": "5S/Clean",
      "wb.maint": "Maintenance",
      "wb.other": "Other",
      "wb.shared": "Shared Capacity",
      "wb.udt": "Unplanned DT",
      "wb.udtUnit": "Unit",
      "wb.net": "Net min/day",
      "wb.scrap": "Scrap %",
      "wb.yield": "Yield",
      "wb.oeeA": "A%",
      "wb.oeeP": "P%",
      "wb.oeeQ": "Q%",
      "wb.oee": "OEE%",
      "wb.ctCur": "CT Current",
      "wb.ctWst": "CT Worst",
      "wb.ctPot": "CT Potential",
      "wb.ctCurOee": "CT@OEE (Cur)",
      "wb.cap100": "Cap 100% (Cur)",
      "wb.capOee": "Cap@OEE (Cur)",
      "wb.vsContract": "% vs contract",
      "wb.inputReq": "Input req. for Contract",
      "wb.actions": "Actions",
      "wb.opsSum": "Operators total:",
      "wb.constraintTitle": "Constraint / Next:",
      "section.statsDetail": "Statistical Detail (per process)",
      "section.dataControls": "Data Controls",
      "btn.copyAll": "Copy All",
      "btn.copySummary": "Copy Summary",
      "btn.addManualLap": "Add Manual Lap",
      "btn.reset": "Reset",
      "section.charts": "Charts (selected process)",
      "label.chartProcessLabel": "Process / Mode:",
      "chart.timeSeriesTitle": "Time Series with Mean, Median, ±3σ",
      "chart.histTitle": "Histogram with Median & Percentiles",
      "section.rawData": "Raw Time Data",
      "col.index": "#",
      "col.status": "Status",
      "col.t1": "T1 (s)",
      "col.t2": "T2 (s)",
      "col.total": "Total (s)",
      "col.edit": "Edit",
      "col.del": "Del",
      "section.methodGuide": "Method & Guide",
      "method.open": "Open",
      "footer.note": "Created by Roberto González – Contact: hzaelglez@gmail.com",
      "msg.noSamples": "No samples yet for current process. Start capturing laps.",
      "msg.needProcess": "Type a process name first (e.g., Op 30-1).",
      "msg.resetConfirm": "This will delete ALL laps + WB rows. Continue?",
      "msg.copied": "Copied ✅",
      "status.ok": "OK",
      "status.exclude": "EXCLUDE"
    },
    es: {
      "title.subtitle": "Analizador de Tiempo Ciclo y Capacidad",
      "btn.start": "Iniciar",
      "btn.lap": "Vuelta",
      "section.measurementSetup": "Configuración de Medición",
      "label.process": "Proceso",
      "label.processPlaceholder": "ej. Op 30-1",
      "label.mode": "Modo",
      "mode.ct": "Tiempo Ciclo (CT)",
      "mode.mld": "Máquina y Carga/Descarga",
      "label.efficiency": "Eficiencia %",
      "label.contractPcd": "Contrato (pzas/día)",
      "label.hoursPerDay": "Horas / Día",
      "label.daysPerWeek": "Días / Semana",
      "label.capView": "Vista Capacidad",
      "capView.hour": "por Hora",
      "capView.day": "por Día",
      "capView.week": "por Semana",
      "section.contractSummary": "Resumen Contrato vs Capacidad",
      "contract.note": "Usa el proceso actual + tus vueltas (Mediana/P10/P90) con los supuestos de Configuración de Medición.",
      "section.statsFocus": "Enfoque Estadístico",
      "stats.note": "Lenguaje simple a propósito: pocas / suficientes muestras, baja / alta variación, capaz / no capaz.",
      "col.process": "Proceso",
      "col.mode": "Modo",
      "col.n": "N",
      "col.sample": "Muestras / Error",
      "col.capCurrent": "Actual @Efic",
      "col.capPotential": "Potencial @Efic",
      "col.capWorst": "Peor @Efic",
      "col.contract": "Contrato",
      "col.gap": "Gap",
      "col.note": "Nota",
      "section.wbPlanner": "WB – Planeador de Capacidad (por proceso)",
      "btn.wbAdd": "+ Agregar Operación",
      "btn.wbClear": "Limpiar WB",
      "wb.enabled": "On",
      "wb.operation": "Operación",
      "wb.operators": "Operadores",
      "wb.shifts": "Turnos",
      "wb.hours": "Horas",
      "wb.machines": "# Máquinas",
      "wb.contract": "Contrato (pzas/día)",
      "wb.gross": "Min brutos/día",
      "wb.lunch": "Comida min/día",
      "wb.changeover": "Cambios",
      "wb.cleaning": "5S/Limpieza",
      "wb.maint": "Manto",
      "wb.other": "Otros",
      "wb.shared": "Capacidad compartida",
      "wb.udt": "Paro no planeado",
      "wb.udtUnit": "Unidad",
      "wb.net": "Min netos/día",
      "wb.scrap": "Scrap %",
      "wb.yield": "Yield",
      "wb.oeeA": "A%",
      "wb.oeeP": "P%",
      "wb.oeeQ": "Q%",
      "wb.oee": "OEE%",
      "wb.ctCur": "CT Actual",
      "wb.ctWst": "CT Peor",
      "wb.ctPot": "CT Potencial",
      "wb.ctCurOee": "CT@OEE (Actual)",
      "wb.cap100": "Cap 100% (Actual)",
      "wb.capOee": "Cap@OEE (Actual)",
      "wb.vsContract": "% vs contrato",
      "wb.inputReq": "Input req. para Contrato",
      "wb.actions": "Acciones",
      "wb.opsSum": "Operadores total:",
      "wb.constraintTitle": "Restricción / Siguiente:",
      "section.statsDetail": "Detalle Estadístico (por proceso)",
      "section.dataControls": "Controles de Datos",
      "btn.copyAll": "Copiar Todo",
      "btn.copySummary": "Copiar Resumen",
      "btn.addManualLap": "Agregar Vuelta Manual",
      "btn.reset": "Reset",
      "section.charts": "Gráficas (proceso seleccionado)",
      "label.chartProcessLabel": "Proceso / Modo:",
      "chart.timeSeriesTitle": "Serie con Media, Mediana, ±3σ",
      "chart.histTitle": "Histograma con Mediana y Percentiles",
      "section.rawData": "Datos Crudos",
      "col.index": "#",
      "col.status": "Estatus",
      "col.t1": "T1 (s)",
      "col.t2": "T2 (s)",
      "col.total": "Total (s)",
      "col.edit": "Editar",
      "col.del": "Borrar",
      "section.methodGuide": "Método y Guía",
      "method.open": "Abrir",
      "footer.note": "Creado por Roberto González – Contacto: hzaelglez@gmail.com",
      "msg.noSamples": "Aún no hay muestras para este proceso. Empieza a capturar vueltas.",
      "msg.needProcess": "Primero escribe un proceso (ej. Op 30-1).",
      "msg.resetConfirm": "Esto borrará TODAS las vueltas + filas de WB. ¿Continuar?",
      "msg.copied": "Copiado ✅",
      "status.ok": "OK",
      "status.exclude": "EXCLUIR"
    }
  };

  let lang = localStorage.getItem("taktlab_lang") || "es";
  function t(key){ return (I18N[lang] && I18N[lang][key]) ? I18N[lang][key] : (I18N.en[key] || key); }

  function applyI18n(){
    document.querySelectorAll("[data-i18n]").forEach(node => {
      const key = node.getAttribute("data-i18n");
      node.textContent = t(key);
    });
    document.querySelectorAll("[data-i18n-placeholder]").forEach(node => {
      const key = node.getAttribute("data-i18n-placeholder");
      node.setAttribute("placeholder", t(key));
    });
    document.querySelectorAll(".lang-btn").forEach(b => b.classList.toggle("active", b.dataset.lang === lang));
  }

  document.querySelectorAll(".lang-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      lang = btn.dataset.lang;
      localStorage.setItem("taktlab_lang", lang);
      applyI18n();
      renderAll();
    });
  });

  /* ---------- Utils ---------- */
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const fmt2 = (n) => (isFinite(n) ? (Math.round(n*100)/100).toFixed(2) : "—");
  const fmt1 = (n) => (isFinite(n) ? (Math.round(n*10)/10).toFixed(1) : "—");
  const fmt0 = (n) => (isFinite(n) ? Math.round(n).toString() : "—");

  function msToClock(ms){
    ms = Math.max(0, ms);
    const totalSec = Math.floor(ms / 1000);
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    const cs = Math.floor((ms % 1000) / 10); // centiseconds
    return `${String(min).padStart(2,"0")}:${String(sec).padStart(2,"0")}.${String(cs).padStart(2,"0")}`;
  }

  function flash(node){
    node.classList.remove("flash");
    void node.offsetWidth;
    node.classList.add("flash");
    setTimeout(()=>node.classList.remove("flash"), 140);
  }

  function safeText(v){ return (v==null) ? "" : String(v); }

  function percentile(sortedArr, p){
    if(!sortedArr.length) return NaN;
    const idx = (sortedArr.length - 1) * p;
    const lo = Math.floor(idx);
    const hi = Math.ceil(idx);
    if(lo === hi) return sortedArr[lo];
    const w = idx - lo;
    return sortedArr[lo]*(1-w) + sortedArr[hi]*w;
  }

  function mean(arr){
    if(!arr.length) return NaN;
    let s=0;
    for(const x of arr) s += x;
    return s/arr.length;
  }

  function stddev(arr){
    if(arr.length < 2) return NaN;
    const m = mean(arr);
    let s=0;
    for(const x of arr) s += (x-m)*(x-m);
    return Math.sqrt(s/(arr.length-1));
  }

  function median(sortedArr){
    if(!sortedArr.length) return NaN;
    const n=sortedArr.length;
    if(n%2) return sortedArr[(n-1)/2];
    return (sortedArr[n/2 - 1] + sortedArr[n/2]) / 2;
  }

  function groupKey(process, mode){
    return `${process}__${mode}`;
  }

  function getCurrentProcess(){
    const p = (el.processName.value || "").trim();
    return p;
  }

  /* ---------- Persistent Data ---------- */
  let laps = [];
  let wbRows = [];

  function loadState(){
    try{
      const raw = localStorage.getItem("taktlab_state_v3");
      if(raw){
        const st = JSON.parse(raw);
        if(Array.isArray(st.laps)) laps = st.laps;
        if(Array.isArray(st.wbRows)) wbRows = st.wbRows;
      }
    }catch(e){}
  }

  function saveState(){
    try{
      localStorage.setItem("taktlab_state_v3", JSON.stringify({ laps, wbRows }));
    }catch(e){}
  }

  /* ---------- Stopwatch Engine ---------- */
  let running = false;
  let rafId = null;

  // segment timing for MLD
  let segStart = 0;         // perfNow baseline
  let segElapsed = 0;       // ms in current segment
  let pendingT1 = null;     // ms captured for T1 in MLD

  function setRunningUI(){
    el.btnStart.textContent = running ? (lang === "es" ? "Pausar" : "Pause") : t("btn.start");
    el.logoGear.classList.toggle("spinning", running);
  }

  function tick(){
    if(!running) return;

    const now = performance.now();
    segElapsed = now - segStart;

    // display clocks
    const mode = el.mode.value;
    if(mode === "CT"){
      el.display.textContent = msToClock(segElapsed);
      el.t1Clock.textContent = msToClock(segElapsed);
      el.t2Clock.textContent = msToClock(0);
    }else{
      // MLD: show current segment live
      if(pendingT1 == null){
        el.t1Clock.textContent = msToClock(segElapsed);
        el.t2Clock.textContent = msToClock(0);
        el.display.textContent = msToClock(segElapsed); // temporary until T2 exists
      }else{
        el.t1Clock.textContent = msToClock(pendingT1);
        el.t2Clock.textContent = msToClock(segElapsed);
        el.display.textContent = msToClock(pendingT1 + segElapsed);
      }
    }

    rafId = requestAnimationFrame(tick);
  }

  function startRun(){
    running = true;
    segStart = performance.now();
    segElapsed = 0;
    setRunningUI();
    rafId = requestAnimationFrame(tick);
  }

  function stopRun(){
    running = false;
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
    setRunningUI();
  }

  function toggleStartPause(){
    if(!getCurrentProcess()){
      alert(t("msg.needProcess"));
      return;
    }
    if(!running){
      // resume from zero; simple and clean
      startRun();
    }else{
      stopRun();
    }
    flash(el.timerCard);
  }

  /* ---------- Lap Capture ---------- */
  function addLapObj(obj){
    laps.push(obj);
    saveState();
    renderAll();
  }

  function captureLap(){
    const process = getCurrentProcess();
    if(!process){
      alert(t("msg.needProcess"));
      return;
    }
    const mode = el.mode.value;
    if(!running){
      // allow capturing by treating current display as 0 — not useful; nudge
      return;
    }

    const now = performance.now();
    const segMs = now - segStart;

    if(mode === "CT"){
      const t1s = segMs / 1000;
      addLapObj({
        id: cryptoRandomId(),
        ts: Date.now(),
        process,
        mode,
        status: t("status.ok"),
        note: "",
        t1: t1s,
        t2: 0,
        total: t1s
      });

      // continue running (restart baseline)
      segStart = performance.now();
      segElapsed = 0;
      flash(el.timerCard);
      return;
    }

    // MLD
    if(pendingT1 == null){
      // capture T1 and move to T2 segment
      pendingT1 = segMs;
      segStart = performance.now();
      segElapsed = 0;
      flash(el.timerCard);
      return;
    }

    // capture T2 and store lap; immediately start next T1 segment
    const t1ms = pendingT1;
    const t2ms = segMs;
    pendingT1 = null;

    const t1s = t1ms/1000;
    const t2s = t2ms/1000;
    addLapObj({
      id: cryptoRandomId(),
      ts: Date.now(),
      process,
      mode,
      status: t("status.ok"),
      note: "",
      t1: t1s,
      t2: t2s,
      total: t1s + t2s
    });

    segStart = performance.now();
    segElapsed = 0;
    flash(el.timerCard);
  }

  /* ---------- Manual Lap ---------- */
  function addManualLap(){
    const process = (prompt(lang==="es" ? "Proceso:" : "Process:", getCurrentProcess() || "") || "").trim();
    if(!process) return;

    const mode = prompt(lang==="es" ? "Modo (CT / MLD):" : "Mode (CT / MLD):", "CT");
    const m = (mode || "CT").toUpperCase() === "MLD" ? "MLD" : "CT";

    let t1 = parseFloat(prompt(lang==="es" ? "T1 (seg):" : "T1 (sec):", "0") || "0");
    let t2 = parseFloat(prompt(lang==="es" ? "T2 (seg):" : "T2 (sec):", "0") || "0");
    if(!isFinite(t1)) t1 = 0;
    if(!isFinite(t2)) t2 = 0;

    const total = (m === "CT") ? t1 : (t1 + t2);

    addLapObj({
      id: cryptoRandomId(),
      ts: Date.now(),
      process,
      mode: m,
      status: t("status.ok"),
      note: (prompt(lang==="es" ? "Nota (opcional):" : "Note (optional):", "") || ""),
      t1,
      t2: (m === "CT") ? 0 : t2,
      total
    });
  }

  /* ---------- Reset ---------- */
  function resetAll(){
    if(!confirm(t("msg.resetConfirm"))) return;
    stopRun();
    segElapsed = 0;
    pendingT1 = null;
    laps = [];
    wbRows = [];
    saveState();
    renderAll();
  }

  /* ---------- Stats Engine ---------- */
  function computeStatsFor(process, mode){
    const rows = laps.filter(r => r.process === process && r.mode === mode && (r.status || "").toUpperCase() !== t("status.exclude"));
    const values = rows.map(r => Number(r.total)).filter(v => isFinite(v) && v > 0);
    const sorted = [...values].sort((a,b)=>a-b);

    const n = sorted.length;
    const mn = mean(sorted);
    const md = median(sorted);
    const p10 = percentile(sorted, 0.10);
    const p90 = percentile(sorted, 0.90);
    const mi = n ? sorted[0] : NaN;
    const ma = n ? sorted[n-1] : NaN;
    const sd = stddev(sorted);
    const cv = (isFinite(sd) && isFinite(mn) && mn>0) ? (sd/mn) : NaN;

    return { n, mean: mn, median: md, p10, p90, min: mi, max: ma, std: sd, cv, values: sorted };
  }

  // sample error model (relative error of mean at 95%)
  function sampleSizing(n, cv){
    const z = 1.96;
    if(!isFinite(cv) || cv<=0 || !isFinite(n) || n<=0){
      return { nReq: NaN, errPct: NaN, status:"neutral" };
    }
    const target = 0.03; // ±3%
    const nReq = Math.ceil(Math.pow((z*cv)/target, 2));
    const err = (z*cv)/Math.sqrt(n); // relative
    const errPct = err*100;

    let status = "bad";
    if(n >= nReq) status = "good";
    else if(n >= 0.75*nReq) status = "warn";

    return { nReq, errPct, status };
  }

  /* ---------- Capacity Engine ---------- */
  function getAssumptions(){
    const eff = clamp(parseFloat(el.efficiency.value || "100")/100, 0, 1);
    const contractPcd = Math.max(0, parseFloat(el.contractPcd.value || "0"));
    const hoursPerDay = clamp(parseFloat(el.hoursPerDay.value || "8"), 0.5, 24);
    const daysPerWeek = clamp(parseInt(el.daysPerWeek.value || "5",10), 1, 7);
    const capView = el.capView.value; // hour/day/week
    return { eff, contractPcd, hoursPerDay, daysPerWeek, capView };
  }

  function availableSecondsPerView(hoursPerDay, daysPerWeek, capView){
    if(capView === "hour") return 3600;
    if(capView === "week") return hoursPerDay * daysPerWeek * 3600;
    return hoursPerDay * 3600;
  }

  function contractPerView(contractPcd, hoursPerDay, daysPerWeek, capView){
    if(capView === "hour") return hoursPerDay > 0 ? (contractPcd / hoursPerDay) : 0;
    if(capView === "week") return contractPcd * daysPerWeek;
    return contractPcd;
  }

  function capacityFromCt(ctSeconds, eff, secondsAvail){
    if(!isFinite(ctSeconds) || ctSeconds <= 0 || !isFinite(secondsAvail) || secondsAvail <= 0) return NaN;
    const effective = secondsAvail * eff;
    return effective / ctSeconds;
  }

  /* ---------- Rendering ---------- */
  function setSampleInfoTop(text, level){
    el.sampleInfoTop.textContent = text;
    el.sampleInfoTop.classList.remove("sample-neutral","sample-good","sample-warn","sample-bad");
    if(level === "good") el.sampleInfoTop.classList.add("sample-good");
    else if(level === "warn") el.sampleInfoTop.classList.add("sample-warn");
    else if(level === "bad") el.sampleInfoTop.classList.add("sample-bad");
    else el.sampleInfoTop.classList.add("sample-neutral");
  }

  function buildTopSampleBanner(){
    const process = getCurrentProcess();
    const mode = el.mode.value;
    if(!process){
      setSampleInfoTop(t("msg.noSamples"), "neutral");
      return;
    }

    const st = computeStatsFor(process, mode);
    if(st.n <= 0 || !isFinite(st.mean) || st.mean<=0){
      setSampleInfoTop(t("msg.noSamples"), "neutral");
      return;
    }

    const sizing = sampleSizing(st.n, st.cv);
    const nReq = sizing.nReq;

    let msg = "";
    if(isFinite(nReq) && nReq > 0 && isFinite(sizing.errPct)){
      if(sizing.status === "good"){
        msg = (lang==="es")
          ? `Muestras: ${st.n} / ${nReq} · Error est.: ±${fmt1(sizing.errPct)}% (95%) – OK para ±3%`
          : `Samples: ${st.n} / ${nReq} · Est. error: ±${fmt1(sizing.errPct)}% (95%) – OK for ±3%`;
      }else if(sizing.status === "warn"){
        msg = (lang==="es")
          ? `Muestras: ${st.n} / ${nReq} · Error est.: ±${fmt1(sizing.errPct)}% (95%) – Casi suficiente, faltan pocas`
          : `Samples: ${st.n} / ${nReq} · Est. error: ±${fmt1(sizing.errPct)}% (95%) – Almost enough, a few more`;
      }else{
        // ✅ this is the exact style you asked to mirror
        msg = (lang==="es")
          ? `Muestras: ${st.n} / ${nReq} · Error est.: ±${fmt1(sizing.errPct)}% (95%) – Muestra muy chica para ±3% – úsalo solo como referencia.`
          : `Samples: ${st.n} / ${nReq} · Est. error: ±${fmt1(sizing.errPct)}% (95%) – Sample too small for ±3% – use only as reference.`;
      }
      setSampleInfoTop(msg, sizing.status);
    }else{
      setSampleInfoTop(lang==="es" ? `Muestras: ${st.n} · Error: —` : `Samples: ${st.n} · Error: —`, "neutral");
    }
  }

  function renderContractSummary(){
    const process = getCurrentProcess();
    const mode = el.mode.value;
    const { eff, contractPcd, hoursPerDay, daysPerWeek, capView } = getAssumptions();

    const secondsAvail = availableSecondsPerView(hoursPerDay, daysPerWeek, capView);
    const contract = contractPerView(contractPcd, hoursPerDay, daysPerWeek, capView);

    if(!process){
      el.contractSumLine1.textContent = "—";
      el.contractSumLine2.textContent = "—";
      el.contractSumLine3.textContent = "—";
      el.contractSumLine4.textContent = "—";
      return;
    }

    const st = computeStatsFor(process, mode);
    if(st.n <= 0 || !isFinite(st.median)){
      el.contractSumLine1.textContent = (lang==="es")
        ? `Proceso: ${process} (${mode}) – sin muestras aún`
        : `Process: ${process} (${mode}) – no samples yet`;
      el.contractSumLine2.textContent = "—";
      el.contractSumLine3.textContent = "—";
      el.contractSumLine4.textContent = "—";
      return;
    }

    const capCur = capacityFromCt(st.median, eff, secondsAvail);
    const capPot = capacityFromCt(st.p10, eff, secondsAvail);
    const capWst = capacityFromCt(st.p90, eff, secondsAvail);

    const viewLabel = (capView === "hour") ? (lang==="es" ? "pzas/h" : "pcs/hr")
                     : (capView === "week") ? (lang==="es" ? "pzas/sem" : "pcs/wk")
                     : (lang==="es" ? "pzas/día" : "pcs/day");

    const cLabel = (lang==="es") ? "Contrato" : "Contract";
    const capLabel = (lang==="es") ? "Capacidad" : "Capacity";

    // Gap uses current
    const gap = (isFinite(capCur) ? (capCur - contract) : NaN);
    const pct = (contract>0 && isFinite(capCur)) ? (capCur/contract*100) : NaN;

    el.contractSumLine1.textContent = (lang==="es")
      ? `Proceso: ${process} (${mode}) · Eficiencia: ${fmt0(eff*100)}% · Vista: ${t("label.capView")} = ${t("capView."+capView)}`
      : `Process: ${process} (${mode}) · Efficiency: ${fmt0(eff*100)}% · View: ${capView}`;
    el.contractSumLine2.textContent = `${cLabel}: ${fmt0(contract)} ${viewLabel}`;
    el.contractSumLine3.textContent = `${capLabel}: ${fmt0(capCur)} ${viewLabel} (Mediana CT=${fmt2(st.median)}s) · Pot=${fmt0(capPot)} · Peor=${fmt0(capWst)}`;
    el.contractSumLine4.textContent = (lang==="es")
      ? `Gap: ${fmt0(gap)} ${viewLabel} · % vs contrato: ${isFinite(pct)?fmt1(pct):"—"}%`
      : `Gap: ${fmt0(gap)} ${viewLabel} · % vs contract: ${isFinite(pct)?fmt1(pct):"—"}%`;
  }

  function capabilityOneSidedCpk(meanCt, stdCt, taktCt){
    if(!isFinite(meanCt) || !isFinite(stdCt) || stdCt<=0 || !isFinite(taktCt) || taktCt<=0) return NaN;
    return (taktCt - meanCt) / (3*stdCt);
  }
  function capabilityCp(stdCt, taktCt){
    if(!isFinite(stdCt) || stdCt<=0 || !isFinite(taktCt) || taktCt<=0) return NaN;
    return (taktCt) / (6*stdCt);
  }

  function renderFocusAndStats(){
    // Build list of groups
    const groups = new Map();
    for(const r of laps){
      const key = groupKey(r.process, r.mode);
      if(!groups.has(key)) groups.set(key, { process:r.process, mode:r.mode });
    }

    // Current focus
    const focusP = getCurrentProcess();
    const focusM = el.mode.value;

    // update focus cards
    const stFocus = focusP ? computeStatsFor(focusP, focusM) : null;

    if(!focusP || !stFocus || stFocus.n<=0){
      el.sampleInfoFocus.textContent = (lang==="es") ? "Muestras: —" : "Sample size: —";
      el.stdInfoFocus.textContent = (lang==="es") ? "Desv. estándar: —" : "Std dev: —";
      el.distInfoFocus.textContent = (lang==="es") ? "Media vs Mediana: —" : "Mean vs Median: —";
      el.contractInfoFocus.textContent = (lang==="es") ? "Sin contrato cargado" : "No contract loaded";
    }else{
      const sizing = sampleSizing(stFocus.n, stFocus.cv);
      const sampleLine = (lang==="es")
        ? `Muestras: ${stFocus.n} / ${isFinite(sizing.nReq)?sizing.nReq:"—"} · Error est.: ${isFinite(sizing.errPct)?("±"+fmt1(sizing.errPct)+"%"):"—"} (95%)`
        : `Sample size: ${stFocus.n} / ${isFinite(sizing.nReq)?sizing.nReq:"—"} · Est. error: ${isFinite(sizing.errPct)?("±"+fmt1(sizing.errPct)+"%"):"—"} (95%)`;
      el.sampleInfoFocus.textContent = sampleLine;

      el.stdInfoFocus.textContent = (lang==="es")
        ? `Desv. estándar: ${fmt2(stFocus.std)}s · CV: ${isFinite(stFocus.cv)?fmt1(stFocus.cv*100):"—"}%`
        : `Std dev: ${fmt2(stFocus.std)}s · CV: ${isFinite(stFocus.cv)?fmt1(stFocus.cv*100):"—"}%`;

      const delta = (isFinite(stFocus.mean)&&isFinite(stFocus.median)) ? (stFocus.mean - stFocus.median) : NaN;
      el.distInfoFocus.textContent = (lang==="es")
        ? `Media=${fmt2(stFocus.mean)}s vs Mediana=${fmt2(stFocus.median)}s · Δ=${isFinite(delta)?fmt2(delta):"—"}s`
        : `Mean=${fmt2(stFocus.mean)}s vs Median=${fmt2(stFocus.median)}s · Δ=${isFinite(delta)?fmt2(delta):"—"}s`;

      const { contractPcd, hoursPerDay, daysPerWeek, capView } = getAssumptions();
      const contract = contractPerView(contractPcd, hoursPerDay, daysPerWeek, capView);
      el.contractInfoFocus.textContent = (lang==="es")
        ? `Contrato (${t("capView."+capView)}): ${fmt0(contract)}`
        : `Contract (${capView}): ${fmt0(contract)}`;
    }

    // Fill focus table (all groups)
    el.focusBody.innerHTML = "";
    el.statsBody.innerHTML = "";

    const { eff, contractPcd, hoursPerDay, daysPerWeek, capView } = getAssumptions();
    const secondsAvail = availableSecondsPerView(hoursPerDay, daysPerWeek, capView);
    const contract = contractPerView(contractPcd, hoursPerDay, daysPerWeek, capView);
    const viewLabel = (capView === "hour") ? (lang==="es" ? "pzas/h" : "pcs/hr")
                     : (capView === "week") ? (lang==="es" ? "pzas/sem" : "pcs/wk")
                     : (lang==="es" ? "pzas/día" : "pcs/day");

    // sort groups by process
    const list = Array.from(groups.values()).sort((a,b)=> (a.process||"").localeCompare(b.process||""));

    for(const g of list){
      const st = computeStatsFor(g.process, g.mode);
      if(st.n<=0) continue;

      const sizing = sampleSizing(st.n, st.cv);
      const capCur = capacityFromCt(st.median, eff, secondsAvail);
      const capPot = capacityFromCt(st.p10, eff, secondsAvail);
      const capWst = capacityFromCt(st.p90, eff, secondsAvail);

      const gap = (isFinite(capCur) ? (capCur - contract) : NaN);
      const pct = (contract>0 && isFinite(capCur)) ? (capCur/contract*100) : NaN;

      // takt CT target from contract (per view) -> seconds/piece
      const takt = (contract>0) ? (secondsAvail/contract) : NaN;
      const cp = capabilityCp(st.std, takt);
      const cpk = capabilityOneSidedCpk(st.mean, st.std, takt);

      let note = "";
      if(sizing.status === "good") note = (lang==="es") ? "Muestra OK ±3%" : "Sample OK ±3%";
      else if(sizing.status === "warn") note = (lang==="es") ? "Casi suficiente" : "Almost enough";
      else note = (lang==="es") ? "Muestra chica (ref.)" : "Small sample (ref.)";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(g.process)}</td>
        <td>${escapeHtml(g.mode)}</td>
        <td>${fmt0(st.n)}</td>
        <td>${(lang==="es" ? "Muestras" : "Samples")}: ${fmt0(st.n)} / ${isFinite(sizing.nReq)?sizing.nReq:"—"} · ±${isFinite(sizing.errPct)?fmt1(sizing.errPct):"—"}%</td>
        <td>${fmt2(st.std)}</td>
        <td>${isFinite(st.cv)?fmt1(st.cv*100):"—"}</td>
        <td>${fmt2(st.median)}</td>
        <td>${fmt2(st.p10)}</td>
        <td>${fmt2(st.p90)}</td>
        <td>${fmt0(capCur)} ${viewLabel}</td>
        <td>${fmt0(capPot)} ${viewLabel}</td>
        <td>${fmt0(capWst)} ${viewLabel}</td>
        <td>${fmt0(contract)} ${viewLabel}</td>
        <td>${fmt0(gap)} ${viewLabel}</td>
        <td>${isFinite(pct)?fmt1(pct):"—"}%</td>
        <td>${isFinite(cp)?fmt2(cp):"—"}</td>
        <td>${isFinite(cpk)?fmt2(cpk):"—"}</td>
        <td>${escapeHtml(note)}</td>
      `;
      el.focusBody.appendChild(tr);

      const tr2 = document.createElement("tr");
      tr2.innerHTML = `
        <td>${escapeHtml(g.process)}</td>
        <td>${escapeHtml(g.mode)}</td>
        <td>${fmt0(st.n)}</td>
        <td>${fmt2(st.mean)}</td>
        <td>${fmt2(st.median)}</td>
        <td>${fmt2(st.p10)}</td>
        <td>${fmt2(st.p90)}</td>
        <td>${fmt2(st.min)}</td>
        <td>${fmt2(st.max)}</td>
        <td>${fmt2(st.std)}</td>
        <td>${isFinite(st.cv)?fmt1(st.cv*100):"—"}</td>
        <td>${isFinite(cp)?fmt2(cp):"—"}</td>
        <td>${isFinite(cpk)?fmt2(cpk):"—"}</td>
      `;
      el.statsBody.appendChild(tr2);
    }

    // Chart selector
    const prev = el.chartProcessSelect.value;
    el.chartProcessSelect.innerHTML = "";
    const optEmpty = document.createElement("option");
    optEmpty.value = "";
    optEmpty.textContent = (lang==="es") ? "— Selecciona —" : "— Select —";
    el.chartProcessSelect.appendChild(optEmpty);

    for(const g of list){
      const st = computeStatsFor(g.process, g.mode);
      if(st.n<=0) continue;
      const o = document.createElement("option");
      o.value = groupKey(g.process, g.mode);
      o.textContent = `${g.process} (${g.mode})`;
      el.chartProcessSelect.appendChild(o);
    }
    if(prev && Array.from(el.chartProcessSelect.options).some(o => o.value === prev)){
      el.chartProcessSelect.value = prev;
    }else{
      // default to current focus if exists
      const focusKey = focusP ? groupKey(focusP, focusM) : "";
      if(focusKey && Array.from(el.chartProcessSelect.options).some(o=>o.value===focusKey)){
        el.chartProcessSelect.value = focusKey;
      }
    }

    renderCharts();
  }

  function renderRawData(){
    el.dataBody.innerHTML = "";
    const rows = [...laps].sort((a,b)=> (a.ts||0) - (b.ts||0));
    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${idx+1}</td>
        <td>${escapeHtml(r.process)}</td>
        <td>${escapeHtml(r.mode)}</td>
        <td>${escapeHtml(r.status || t("status.ok"))}</td>
        <td>${escapeHtml(r.note || "")}</td>
        <td>${fmt2(r.t1)}</td>
        <td>${fmt2(r.t2)}</td>
        <td>${fmt2(r.total)}</td>
        <td><button class="btn-edit" data-id="${r.id}">${lang==="es" ? "Editar" : "Edit"}</button></td>
        <td><button class="btn-del" data-id="${r.id}">${lang==="es" ? "Borrar" : "Del"}</button></td>
      `;
      el.dataBody.appendChild(tr);
    });

    // edit/del
    el.dataBody.querySelectorAll(".btn-edit").forEach(b => {
      b.addEventListener("click", () => {
        const id = b.dataset.id;
        const idx = laps.findIndex(x => x.id === id);
        if(idx<0) return;
        const r = laps[idx];

        const status = prompt(lang==="es" ? "Estatus (OK / EXCLUIR):" : "Status (OK / EXCLUDE):", r.status || t("status.ok"));
        const note = prompt(lang==="es" ? "Nota:" : "Note:", r.note || "");

        let t1 = parseFloat(prompt(lang==="es" ? "T1 (seg):" : "T1 (sec):", String(r.t1)) || String(r.t1));
        let t2 = parseFloat(prompt(lang==="es" ? "T2 (seg):" : "T2 (sec):", String(r.t2)) || String(r.t2));
        if(!isFinite(t1)) t1 = 0;
        if(!isFinite(t2)) t2 = 0;

        const total = (r.mode === "CT") ? t1 : (t1 + t2);

        laps[idx] = { ...r, status: safeText(status), note: safeText(note), t1, t2: (r.mode==="CT"?0:t2), total };
        saveState();
        renderAll();
      });
    });

    el.dataBody.querySelectorAll(".btn-del").forEach(b => {
      b.addEventListener("click", () => {
        const id = b.dataset.id;
        laps = laps.filter(x => x.id !== id);
        saveState();
        renderAll();
      });
    });
  }

  /* ---------- Charts ---------- */
  function clearCanvas(c){
    const ctx = c.getContext("2d");
    ctx.clearRect(0,0,c.width,c.height);
  }

  function setupCanvasDpi(c){
    const rect = c.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    c.width = Math.floor(rect.width * dpr);
    c.height = Math.floor(rect.height * dpr);
    const ctx = c.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function renderCharts(){
    setupCanvasDpi(el.timeSeriesCanvas);
    setupCanvasDpi(el.histCanvas);

    const key = el.chartProcessSelect.value;
    if(!key){
      clearCanvas(el.timeSeriesCanvas);
      clearCanvas(el.histCanvas);
      return;
    }
    const [process, mode] = key.split("__");
    const st = computeStatsFor(process, mode);
    if(st.n<=0){
      clearCanvas(el.timeSeriesCanvas);
      clearCanvas(el.histCanvas);
      return;
    }

    drawTimeSeries(el.timeSeriesCanvas, st);
    drawHistogram(el.histCanvas, st);
  }

  function drawTimeSeries(canvas, st){
    const ctx = canvas.getContext("2d");
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const pad = 22;
    const x0 = pad, y0 = pad, x1 = w - pad, y1 = h - pad;

    const data = st.values.slice(0); // sorted, but ok
    // For time series, use original order for this group
    const series = laps
      .filter(r => r.process === currentSeriesProcess() && r.mode === currentSeriesMode() && (r.status||"").toUpperCase() !== t("status.exclude"))
      .map(r => Number(r.total))
      .filter(v => isFinite(v) && v > 0);

    const vals = series.length ? series : data;
    const n = vals.length;

    const mn = st.mean;
    const md = st.median;
    const sd = st.std;

    let lo = Math.min(...vals, isFinite(mn-3*sd)?(mn-3*sd):Infinity);
    let hi = Math.max(...vals, isFinite(mn+3*sd)?(mn+3*sd):-Infinity);
    if(!isFinite(lo) || !isFinite(hi) || lo===hi){
      lo = Math.min(...vals);
      hi = Math.max(...vals);
      if(lo===hi){ lo = lo*0.9; hi = hi*1.1; }
    }

    const x = (i) => x0 + (n<=1 ? 0 : (i/(n-1))*(x1-x0));
    const y = (v) => y1 - ((v - lo)/(hi - lo))*(y1-y0);

    // axes
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x0,y1); ctx.lineTo(x1,y1);
    ctx.moveTo(x0,y0); ctx.lineTo(x0,y1);
    ctx.stroke();

    // series
    ctx.strokeStyle = "rgba(255,255,255,.70)";
    ctx.lineWidth = 1.25;
    ctx.beginPath();
    vals.forEach((v,i)=>{
      const px = x(i), py = y(v);
      if(i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    });
    ctx.stroke();

    // mean line
    if(isFinite(mn)){
      ctx.strokeStyle = "rgba(57,189,245,.85)";
      ctx.setLineDash([4,3]);
      ctx.beginPath();
      ctx.moveTo(x0, y(mn)); ctx.lineTo(x1, y(mn));
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // median line
    if(isFinite(md)){
      ctx.strokeStyle = "rgba(242,193,78,.85)";
      ctx.setLineDash([3,4]);
      ctx.beginPath();
      ctx.moveTo(x0, y(md)); ctx.lineTo(x1, y(md));
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ±3σ
    if(isFinite(mn) && isFinite(sd)){
      const up = mn + 3*sd;
      const dn = mn - 3*sd;
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.setLineDash([2,6]);
      ctx.beginPath(); ctx.moveTo(x0, y(up)); ctx.lineTo(x1, y(up)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x0, y(dn)); ctx.lineTo(x1, y(dn)); ctx.stroke();
      ctx.setLineDash([]);
    }

    // labels
    ctx.fillStyle = "rgba(255,255,255,.65)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.fillText(`${fmt2(lo)}s`, 4, y1);
    ctx.fillText(`${fmt2(hi)}s`, 4, y0+6);

    function currentSeriesProcess(){ return (processFromKey(el.chartProcessSelect.value)); }
    function currentSeriesMode(){ return (modeFromKey(el.chartProcessSelect.value)); }
    function processFromKey(k){ return (k||"").split("__")[0] || ""; }
    function modeFromKey(k){ return (k||"").split("__")[1] || ""; }
  }

  function drawHistogram(canvas, st){
    const ctx = canvas.getContext("2d");
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    const pad = 22;
    const x0 = pad, y0 = pad, x1 = w - pad, y1 = h - pad;

    const vals = st.values.slice(0);
    const n = vals.length;
    const lo = vals[0], hi = vals[n-1];
    const bins = clamp(Math.round(Math.sqrt(n)), 5, 18);
    const bw = (hi - lo) / bins || 1;

    const counts = new Array(bins).fill(0);
    for(const v of vals){
      let bi = Math.floor((v - lo)/bw);
      if(bi>=bins) bi = bins-1;
      if(bi<0) bi=0;
      counts[bi]++;
    }
    const maxC = Math.max(...counts, 1);

    // axes
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x0,y1); ctx.lineTo(x1,y1);
    ctx.moveTo(x0,y0); ctx.lineTo(x0,y1);
    ctx.stroke();

    // bars
    const barW = (x1-x0)/bins;
    ctx.fillStyle = "rgba(255,255,255,.22)";
    counts.forEach((c,i)=>{
      const bh = (c/maxC)*(y1-y0);
      ctx.fillRect(x0 + i*barW + 1, y1 - bh, barW - 2, bh);
    });

    // median + percentiles
    const md = st.median, p10 = st.p10, p90 = st.p90;

    const xFromV = (v) => x0 + ((v - lo)/(hi - lo || 1))*(x1-x0);

    if(isFinite(p10)){
      ctx.strokeStyle = "rgba(24,201,122,.85)";
      ctx.setLineDash([2,6]);
      ctx.beginPath(); ctx.moveTo(xFromV(p10), y0); ctx.lineTo(xFromV(p10), y1); ctx.stroke();
      ctx.setLineDash([]);
    }
    if(isFinite(md)){
      ctx.strokeStyle = "rgba(242,193,78,.85)";
      ctx.setLineDash([3,4]);
      ctx.beginPath(); ctx.moveTo(xFromV(md), y0); ctx.lineTo(xFromV(md), y1); ctx.stroke();
      ctx.setLineDash([]);
    }
    if(isFinite(p90)){
      ctx.strokeStyle = "rgba(255,51,85,.75)";
      ctx.setLineDash([2,6]);
      ctx.beginPath(); ctx.moveTo(xFromV(p90), y0); ctx.lineTo(xFromV(p90), y1); ctx.stroke();
      ctx.setLineDash([]);
    }

    // labels
    ctx.fillStyle = "rgba(255,255,255,.65)";
    ctx.font = "12px system-ui, sans-serif";
    ctx.fillText(`${fmt2(lo)}s`, x0, h-6);
    ctx.fillText(`${fmt2(hi)}s`, x1-45, h-6);
  }

  el.chartProcessSelect.addEventListener("change", renderCharts);
  window.addEventListener("resize", () => { renderCharts(); });

  /* ---------- WB Planner ---------- */
  function defaultWbRow(){
    const { hoursPerDay } = getAssumptions();
    const grossMin = Math.round(hoursPerDay * 60);
    return {
      id: cryptoRandomId(),
      on: true,
      operationKey: "",
      operators: 1,
      shifts: 1,
      hours: hoursPerDay,
      machines: 1,
      contractPcd: 0,

      grossMin: grossMin,
      lunchMin: 0,
      changeoverMin: 0,
      cleaningMin: 0,
      maintMin: 0,
      otherMin: 0,

      sharedPct: 0,

      udtVal: 0,
      udtUnit: "min", // "min" or "pct"

      scrapPct: 0,

      A: 100,
      P: 100,
      Q: 100
    };
  }

  function listAvailableOps(){
    const set = new Set();
    for(const r of laps){
      if(r.process && r.mode){
        set.add(groupKey(r.process, r.mode));
      }
    }
    return Array.from(set).sort();
  }

  function statsForKey(key){
    if(!key) return null;
    const [p,m] = key.split("__");
    return computeStatsFor(p,m);
  }

  function calcOee(row){
    const A = clamp((+row.A||0)/100, 0, 1);
    const P = clamp((+row.P||0)/100, 0, 1);
    const Q = clamp((+row.Q||0)/100, 0, 1);
    return A*P*Q;
  }

  function calcYield(row){
    const scrap = clamp((+row.scrapPct||0)/100, 0, 1);
    return 1 - scrap;
  }

  function calcNetMinutes(row){
    const gross = Math.max(0, +row.grossMin || 0);

    const planned = Math.max(0,+row.lunchMin||0)
                 + Math.max(0,+row.changeoverMin||0)
                 + Math.max(0,+row.cleaningMin||0)
                 + Math.max(0,+row.maintMin||0)
                 + Math.max(0,+row.otherMin||0);

    const shared = gross * clamp((+row.sharedPct||0)/100, 0, 1);

    let udt = 0;
    if(row.udtUnit === "pct"){
      udt = gross * clamp((+row.udtVal||0)/100, 0, 1);
    }else{
      udt = Math.max(0, +row.udtVal || 0);
    }

    const net = gross - planned - shared - udt;
    return Math.max(0, net);
  }

  function wbCapacity(row){
    const st = statsForKey(row.operationKey);
    const netMin = calcNetMinutes(row);
    const netSec = netMin * 60;

    const machines = Math.max(1, +row.machines || 1);
    const oee = calcOee(row);
    const yieldP = calcYield(row);

    let ctCur = st && isFinite(st.median) ? st.median : NaN;
    let ctWst = st && isFinite(st.p90) ? st.p90 : NaN;
    let ctPot = st && isFinite(st.p10) ? st.p10 : NaN;

    const ctCurOee = (isFinite(ctCur) && oee>0) ? (ctCur / oee) : NaN;

    const cap100 = (isFinite(ctCur) && ctCur>0) ? ((netSec / ctCur) * machines) : NaN;
    const capOee = (isFinite(ctCurOee) && ctCurOee>0) ? ((netSec / ctCurOee) * machines) : NaN;

    const goodCap = (isFinite(capOee)) ? (capOee * yieldP) : NaN;

    const contract = Math.max(0, +row.contractPcd || 0);
    const pctVs = (contract>0 && isFinite(goodCap)) ? (goodCap/contract*100) : NaN;

    const inputReq = (yieldP>0) ? (contract / yieldP) : NaN;

    return {
      netMin,
      oee,
      yieldP,
      ctCur, ctWst, ctPot,
      ctCurOee,
      cap100,
      capOee: goodCap,
      pctVs,
      inputReq
    };
  }

  function renderWb(){
    // ensure rows exist in storage (but don't force)
    const ops = listAvailableOps();
    el.wbBody.innerHTML = "";

    wbRows.forEach((row) => {
      const calc = wbCapacity(row);

      const tr = document.createElement("tr");

      const opLabel = (row.operationKey && ops.includes(row.operationKey))
        ? row.operationKey
        : "";

      tr.innerHTML = `
        <td>
          <input class="wb-chk" type="checkbox" ${row.on ? "checked":""} data-k="on" data-id="${row.id}">
        </td>

        <td>
          <div class="wb-opwrap">
            <select class="wb-opselect" data-k="operationKey" data-id="${row.id}">
              <option value="">${lang==="es" ? "— Selecciona —" : "— Select —"}</option>
              ${ops.map(k => `<option value="${escapeHtml(k)}" ${k===opLabel?"selected":""}>${escapeHtml(k.replace("__"," (") + ")")}</option>`).join("")}
            </select>
            <button class="wb-opbtn btn-relink" title="${lang==="es" ? "Cargar del proceso actual" : "Link to current process"}" data-act="relink" data-id="${row.id}">↩</button>
          </div>
        </td>

        <td><input class="wb-inp slim" type="number" step="1" min="0" data-k="operators" data-id="${row.id}" value="${fmt0(row.operators)}"></td>
        <td><input class="wb-inp slim" type="number" step="1" min="1" data-k="shifts" data-id="${row.id}" value="${fmt0(row.shifts)}"></td>
        <td><input class="wb-inp slim" type="number" step=".5" min="0" data-k="hours" data-id="${row.id}" value="${fmt1(row.hours)}"></td>
        <td><input class="wb-inp slim" type="number" step="1" min="1" data-k="machines" data-id="${row.id}" value="${fmt0(row.machines)}"></td>
        <td><input class="wb-inp" type="number" step="1" min="0" data-k="contractPcd" data-id="${row.id}" value="${fmt0(row.contractPcd)}"></td>

        <td><input class="wb-inp" type="number" step="1" min="0" data-k="grossMin" data-id="${row.id}" value="${fmt0(row.grossMin)}"></td>
        <td><input class="wb-inp" type="number" step="1" min="0" data-k="lunchMin" data-id="${row.id}" value="${fmt0(row.lunchMin)}"></td>
        <td><input class="wb-inp" type="number" step="1" min="0" data-k="changeoverMin" data-id="${row.id}" value="${fmt0(row.changeoverMin)}"></td>
        <td><input class="wb-inp" type="number" step="1" min="0" data-k="cleaningMin" data-id="${row.id}" value="${fmt0(row.cleaningMin)}"></td>
        <td><input class="wb-inp" type="number" step="1" min="0" data-k="maintMin" data-id="${row.id}" value="${fmt0(row.maintMin)}"></td>
        <td><input class="wb-inp" type="number" step="1" min="0" data-k="otherMin" data-id="${row.id}" value="${fmt0(row.otherMin)}"></td>

        <td><input class="wb-inp slim" type="number" step="1" min="0" max="100" data-k="sharedPct" data-id="${row.id}" value="${fmt0(row.sharedPct)}"></td>

        <td><input class="wb-inp slim" type="number" step="1" min="0" data-k="udtVal" data-id="${row.id}" value="${fmt0(row.udtVal)}"></td>
        <td>
          <select class="wb-sel" data-k="udtUnit" data-id="${row.id}">
            <option value="min" ${row.udtUnit==="min"?"selected":""}>min</option>
            <option value="pct" ${row.udtUnit==="pct"?"selected":""}>%</option>
          </select>
        </td>

        <td><span class="wb-pill">${fmt0(calc.netMin)}</span></td>

        <td><input class="wb-inp slim" type="number" step=".1" min="0" max="100" data-k="scrapPct" data-id="${row.id}" value="${fmt1(row.scrapPct)}"></td>
        <td><span class="wb-pill">${fmt1(calc.yieldP*100)}%</span></td>

        <td><input class="wb-inp slim" type="number" step="1" min="0" max="100" data-k="A" data-id="${row.id}" value="${fmt0(row.A)}"></td>
        <td><input class="wb-inp slim" type="number" step="1" min="0" max="100" data-k="P" data-id="${row.id}" value="${fmt0(row.P)}"></td>
        <td><input class="wb-inp slim" type="number" step="1" min="0" max="100" data-k="Q" data-id="${row.id}" value="${fmt0(row.Q)}"></td>
        <td><span class="wb-pill">${fmt1(calc.oee*100)}%</span></td>

        <td><span class="wb-pill">${isFinite(calc.ctCur)?fmt2(calc.ctCur):"—"}</span></td>
        <td><span class="wb-pill">${isFinite(calc.ctWst)?fmt2(calc.ctWst):"—"}</span></td>
        <td><span class="wb-pill">${isFinite(calc.ctPot)?fmt2(calc.ctPot):"—"}</span></td>

        <td><span class="wb-pill">${isFinite(calc.ctCurOee)?fmt2(calc.ctCurOee):"—"}</span></td>

        <td><span class="wb-pill">${isFinite(calc.cap100)?fmt0(calc.cap100):"—"}</span></td>
        <td><span class="wb-pill">${isFinite(calc.capOee)?fmt0(calc.capOee):"—"}</span></td>

        <td><span class="wb-pill">${isFinite(calc.pctVs)?fmt1(calc.pctVs):"—"}%</span></td>
        <td><span class="wb-pill">${isFinite(calc.inputReq)?fmt0(calc.inputReq):"—"}</span></td>

        <td>
          <button class="wb-opbtn btn-del" data-act="del" data-id="${row.id}">${lang==="es" ? "Borrar" : "Del"}</button>
        </td>
      `;
      el.wbBody.appendChild(tr);
    });

    // bind inputs
    el.wbBody.querySelectorAll("input,select").forEach(inp => {
      inp.addEventListener("change", () => {
        const id = inp.getAttribute("data-id");
        const k = inp.getAttribute("data-k");
        const row = wbRows.find(r => r.id === id);
        if(!row) return;

        if(inp.type === "checkbox"){
          row[k] = inp.checked;
        }else if(k === "operationKey" || k === "udtUnit"){
          row[k] = inp.value;
        }else{
          row[k] = parseFloat(inp.value);
          if(!isFinite(row[k])) row[k] = 0;
        }
        saveState();
        renderWbSummary();
        renderWb(); // keep computed fields live
      });
    });

    // relink / del actions
    el.wbBody.querySelectorAll("button[data-act]").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-id");
        const act = btn.getAttribute("data-act");
        const row = wbRows.find(r => r.id === id);
        if(!row) return;

        if(act === "del"){
          wbRows = wbRows.filter(r => r.id !== id);
          saveState();
          renderAll();
        }else if(act === "relink"){
          const p = getCurrentProcess();
          const m = el.mode.value;
          if(p){
            row.operationKey = groupKey(p,m);
            saveState();
            renderAll();
          }
        }
      });
    });

    renderWbSummary();
  }

  function renderWbSummary(){
    // operators sum
    const totalOps = wbRows
      .filter(r => r.on)
      .reduce((s,r)=> s + Math.max(0, +r.operators || 0), 0);
    el.wbOperatorsSum.textContent = fmt0(totalOps);

    // constraint: lowest %vs contract (among enabled with contract>0)
    const scored = wbRows
      .filter(r => r.on)
      .map(r => {
        const calc = wbCapacity(r);
        return { r, calc };
      })
      .filter(x => (x.r.contractPcd||0) > 0 && isFinite(x.calc.pctVs));

    scored.sort((a,b)=> a.calc.pctVs - b.calc.pctVs);

    const top = scored[0];
    const next = scored[1];

    if(top){
      const label = wbLabel(top.r);
      el.wbConstraint.textContent = `${label} · ${fmt1(top.calc.pctVs)}%`;
      el.wbConstraint.className = "badge badge-bad";
    }else{
      el.wbConstraint.textContent = "—";
      el.wbConstraint.className = "badge badge-bad";
    }

    if(next){
      const label2 = wbLabel(next.r);
      el.wbNextConstraint.textContent = `${label2} · ${fmt1(next.calc.pctVs)}%`;
      el.wbNextConstraint.className = "badge badge-warn";
    }else{
      el.wbNextConstraint.textContent = "—";
      el.wbNextConstraint.className = "badge badge-warn";
    }

    // note
    if(top){
      const c = wbCapacity(top.r);
      const hint = (lang==="es")
        ? `Net min/día=${fmt0(c.netMin)} · OEE=${fmt1(c.oee*100)}% · Yield=${fmt1(c.yieldP*100)}% · Cap@OEE=${fmt0(c.capOee)} vs Contrato=${fmt0(top.r.contractPcd)}`
        : `Net min/day=${fmt0(c.netMin)} · OEE=${fmt1(c.oee*100)}% · Yield=${fmt1(c.yieldP*100)}% · Cap@OEE=${fmt0(c.capOee)} vs Contract=${fmt0(top.r.contractPcd)}`;
      el.wbConstraintNote.textContent = hint;
    }else{
      el.wbConstraintNote.textContent = (lang==="es")
        ? "Tip: agrega contratos por operación en WB para identificar restricción automáticamente."
        : "Tip: add per-operation contracts in WB to identify the constraint automatically.";
    }

    function wbLabel(row){
      if(!row.operationKey) return (lang==="es" ? "Sin ligar" : "Unlinked");
      const [p,m] = row.operationKey.split("__");
      return `${p} (${m})`;
    }
  }

  function addWbRow(){
    wbRows.push(defaultWbRow());
    saveState();
    renderAll();
  }

  function clearWb(){
    wbRows = [];
    saveState();
    renderAll();
  }

  /* ---------- Copy ---------- */
  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast(t("msg.copied"));
    }catch(e){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast(t("msg.copied"));
    }
  }

  function buildSummaryText(){
    const { eff, contractPcd, hoursPerDay, daysPerWeek, capView } = getAssumptions();
    const process = getCurrentProcess();
    const mode = el.mode.value;

    const lines = [];
    lines.push(`TaktLab Summary`);
    lines.push(`Lang: ${lang}`);
    lines.push(`Assumptions: Eff=${fmt0(eff*100)}% · Contract/day=${fmt0(contractPcd)} · Hrs/day=${fmt1(hoursPerDay)} · Days/week=${fmt0(daysPerWeek)} · View=${capView}`);
    lines.push(`Focus: ${process || "—"} (${mode})`);
    lines.push("");

    // Focus stats
    if(process){
      const st = computeStatsFor(process, mode);
      if(st.n>0){
        const sizing = sampleSizing(st.n, st.cv);
        lines.push(`Stats: N=${st.n} · Mean=${fmt2(st.mean)}s · Median=${fmt2(st.median)}s · P10=${fmt2(st.p10)}s · P90=${fmt2(st.p90)}s · Std=${fmt2(st.std)}s · CV=${isFinite(st.cv)?fmt1(st.cv*100):"—"}%`);
        lines.push(`Samples: ${st.n}/${isFinite(sizing.nReq)?sizing.nReq:"—"} · Est error: ${isFinite(sizing.errPct)?("±"+fmt1(sizing.errPct)+"%"):"—"} (95%)`);
      }else{
        lines.push(`Stats: —`);
      }
    }

    lines.push("");
    lines.push(`WB rows: ${wbRows.length}`);
    wbRows.forEach((r,i)=>{
      const c = wbCapacity(r);
      lines.push(`WB#${i+1} ${r.on?"[ON]":"[OFF]"} ${r.operationKey||"—"} · Contract=${fmt0(r.contractPcd)} · Cap@OEE=${fmt0(c.capOee)} · %vs=${isFinite(c.pctVs)?fmt1(c.pctVs):"—"}% · NetMin=${fmt0(c.netMin)} · OEE=${fmt1(c.oee*100)}% · Yield=${fmt1(c.yieldP*100)}%`);
    });

    return lines.join("\n");
  }

  function buildAllText(){
    const dump = {
      lang,
      assumptions: getAssumptions(),
      focus: { process: getCurrentProcess(), mode: el.mode.value },
      laps,
      wbRows
    };
    return JSON.stringify(dump, null, 2);
  }

  /* ---------- Toast ---------- */
  let toastTimer = null;
  function toast(msg){
    let box = document.getElementById("toastBox");
    if(!box){
      box = document.createElement("div");
      box.id = "toastBox";
      box.style.position = "fixed";
      box.style.left = "50%";
      box.style.bottom = "16px";
      box.style.transform = "translateX(-50%)";
      box.style.padding = "10px 14px";
      box.style.borderRadius = "999px";
      box.style.border = "1px solid rgba(255,255,255,.18)";
      box.style.background = "rgba(2,11,26,.85)";
      box.style.color = "white";
      box.style.font = "600 13px system-ui, sans-serif";
      box.style.zIndex = 9999;
      box.style.boxShadow = "0 10px 22px rgba(0,0,0,.45)";
      document.body.appendChild(box);
    }
    box.textContent = msg;
    box.style.opacity = "1";
    if(toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>{ box.style.opacity="0"; }, 1200);
  }

  /* ---------- Method Guide ---------- */
  function renderMethodGuide(){
    el.methodGuideText.textContent = (lang==="es")
      ? [
        "✅ Flujo recomendado:",
        "1) Escribe Proceso (ej. Op 30-1).",
        "2) Selecciona Modo: CT o MLD.",
        "3) Iniciar. Luego usa Vuelta:",
        "   - CT: cada Vuelta guarda un ciclo (Total).",
        "   - MLD: Vuelta #1 guarda T1, Vuelta #2 guarda T2 y cierra el ciclo (T1+T2).",
        "4) Ajusta Eficiencia / Horas / Días / Contrato.",
        "5) Revisa Resumen Contrato vs Capacidad y la calidad de tu muestra (±3%).",
        "6) WB: liga operaciones a procesos medidos para simular capacidad real con Net min, OEE y Yield.",
        "",
        "💡 Tip: si la Media se aleja de la Mediana, tu distribución está sesgada (colas). Usa Mediana/P90 para decisiones operativas."
      ].join("\n")
      : [
        "✅ Recommended flow:",
        "1) Type Process (e.g., Op 30-1).",
        "2) Select Mode: CT or MLD.",
        "3) Start. Then use LAP:",
        "   - CT: each LAP stores one cycle (Total).",
        "   - MLD: LAP #1 captures T1, LAP #2 captures T2 and closes the cycle (T1+T2).",
        "4) Set Efficiency / Hours / Days / Contract.",
        "5) Check Contract vs Capacity and your sample quality (±3%).",
        "6) WB: link operations to measured processes to simulate real capacity with Net min, OEE and Yield.",
        "",
        "💡 Tip: if Mean drifts from Median, your distribution is skewed (tails). Use Median/P90 for operational decisions."
      ].join("\n");
  }

  /* ---------- Events ---------- */
  el.btnStart.addEventListener("click", toggleStartPause);
  el.btnLap.addEventListener("click", captureLap);

  el.mode.addEventListener("change", () => {
    // reset MLD pending segment when switching mode
    pendingT1 = null;
    segElapsed = 0;
    if(!running){
      el.display.textContent = "00:00.00";
      el.t1Clock.textContent = "00:00.00";
      el.t2Clock.textContent = "00:00.00";
    }
    renderAll();
  });

  ["input","change"].forEach(evt => {
    el.processName.addEventListener(evt, () => { renderAll(); });
    el.efficiency.addEventListener(evt, () => { renderAll(); });
    el.contractPcd.addEventListener(evt, () => { renderAll(); });
    el.hoursPerDay.addEventListener(evt, () => { renderAll(); });
    el.daysPerWeek.addEventListener(evt, () => { renderAll(); });
    el.capView.addEventListener(evt, () => { renderAll(); });
  });

  el.btnCopyAll.addEventListener("click", () => copyText(buildAllText()));
  el.btnCopySummary.addEventListener("click", () => copyText(buildSummaryText()));
  el.btnAddManualLap.addEventListener("click", addManualLap);
  el.btnReset.addEventListener("click", resetAll);

  el.btnWbAdd.addEventListener("click", addWbRow);
  el.btnWbClear.addEventListener("click", clearWb);

  // Keyboard shortcuts: Space start/pause, Enter lap
  window.addEventListener("keydown", (e) => {
    if(e.target && (e.target.tagName==="INPUT" || e.target.tagName==="TEXTAREA" || e.target.tagName==="SELECT")) return;
    if(e.code === "Space"){
      e.preventDefault();
      toggleStartPause();
    }
    if(e.code === "Enter"){
      e.preventDefault();
      captureLap();
    }
  });

  /* ---------- Render All ---------- */
  function renderAll(){
    applyI18n();
    buildTopSampleBanner();
    renderContractSummary();
    renderFocusAndStats();
    renderRawData();
    renderWb();
    renderMethodGuide();
  }

  /* ---------- Helpers ---------- */
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function cryptoRandomId(){
    // simple, collision-resistant enough for local app
    return (crypto && crypto.getRandomValues)
      ? Array.from(crypto.getRandomValues(new Uint32Array(2))).map(n=>n.toString(16)).join("-")
      : `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }

  /* ---------- Init ---------- */
  loadState();
  applyI18n();
  setRunningUI();
  renderAll();

})();
</script>

</body>
</html>
<!-- =========================
     TaktLab – Part 3 (CSS for WB + small UI fixes)
     PÉGALO justo DESPUÉS del </style> de la Parte 1
     (o al final del <style> existente)
     ========================= -->

<style>
  /* ---- Small fixes: make Contract Summary BEFORE Stats Focus feel stronger ---- */
  .section-title{
    letter-spacing:.2px;
  }
  #contractSummaryCard{
    border:1px solid rgba(57,189,245,.22);
    box-shadow: 0 18px 40px rgba(0,0,0,.24);
  }

  /* ---- Data Controls bigger + colorful buttons (Reset red) ---- */
  #dataControls .btn{
    padding:12px 14px;
    font-weight:800;
    border-radius:14px;
  }
  #btnCopyAll{ background: linear-gradient(180deg, rgba(57,189,245,.95), rgba(57,189,245,.70)); border:1px solid rgba(255,255,255,.18); }
  #btnCopySummary{ background: linear-gradient(180deg, rgba(242,193,78,.95), rgba(242,193,78,.70)); border:1px solid rgba(255,255,255,.18); }
  #btnAddManualLap{ background: linear-gradient(180deg, rgba(24,201,122,.95), rgba(24,201,122,.70)); border:1px solid rgba(255,255,255,.18); }
  #btnReset{ background: linear-gradient(180deg, rgba(255,51,85,.95), rgba(255,51,85,.70)); border:1px solid rgba(255,255,255,.18); }
  #dataControls .btn:hover{ transform: translateY(-1px); }
  #dataControls .btn:active{ transform: translateY(0px); }

  /* =========================
     WB – table layout
     ========================= */
  #wbCard{
    border:1px solid rgba(242,193,78,.20);
    box-shadow: 0 18px 40px rgba(0,0,0,.22);
  }

  .wb-table-wrap{
    width:100%;
    overflow:auto;
    border:1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    background: rgba(3,14,32,.35);
  }

  table.wb{
    width: max(1400px, 100%);
    border-collapse: collapse;
    font-size: 12.5px;
  }

  table.wb thead th{
    position: sticky;
    top: 0;
    z-index: 2;
    background: rgba(9,26,49,.95);
    color: rgba(255,255,255,.85);
    text-align: left;
    padding: 10px 8px;
    border-bottom: 1px solid rgba(255,255,255,.12);
    white-space: nowrap;
  }

  table.wb tbody td{
    padding: 8px 8px;
    border-bottom: 1px solid rgba(255,255,255,.08);
    vertical-align: middle;
    white-space: nowrap;
  }

  table.wb tbody tr:hover{
    background: rgba(255,255,255,.04);
  }

  /* Inputs */
  .wb-inp, .wb-sel{
    width: 120px;
    padding: 7px 8px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(5,18,38,.55);
    color: rgba(255,255,255,.92);
    outline: none;
  }
  .wb-inp:focus, .wb-sel:focus{
    border-color: rgba(57,189,245,.55);
    box-shadow: 0 0 0 3px rgba(57,189,245,.18);
  }
  .wb-inp.slim{ width: 86px; }

  .wb-chk{
    transform: scale(1.15);
    accent-color: var(--accent-green);
  }

  /* Operation select + relink */
  .wb-opwrap{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .wb-opselect{
    min-width: 260px;
    width: 320px;
    padding: 7px 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(5,18,38,.55);
    color: rgba(255,255,255,.92);
    outline: none;
  }
  .wb-opselect:focus{
    border-color: rgba(57,189,245,.55);
    box-shadow: 0 0 0 3px rgba(57,189,245,.18);
  }

  .wb-opbtn{
    padding: 7px 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.92);
    cursor: pointer;
    transition: transform .12s ease, background .12s ease;
    font-weight: 800;
  }
  .wb-opbtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
  .wb-opbtn:active{ transform: translateY(0px); }

  .wb-opbtn.btn-del{
    background: rgba(255,51,85,.14);
    border-color: rgba(255,51,85,.28);
  }

  .wb-pill{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
    color: rgba(255,255,255,.92);
    min-width: 76px;
    font-weight: 800;
  }

  /* WB header badges area */
  .wb-topbar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    flex-wrap: wrap;
    margin: 10px 0 12px;
  }
  .wb-topbar .left,
  .wb-topbar .right{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap: wrap;
  }

  /* Make "Add Operation" and "Clear WB" pop */
  #btnWbAdd{
    background: linear-gradient(180deg, rgba(24,201,122,.95), rgba(24,201,122,.70));
    border: 1px solid rgba(255,255,255,.18);
    font-weight: 900;
    padding: 10px 12px;
    border-radius: 14px;
  }
  #btnWbClear{
    background: rgba(255,51,85,.14);
    border: 1px solid rgba(255,51,85,.28);
    font-weight: 900;
    padding: 10px 12px;
    border-radius: 14px;
  }

  /* Slightly larger "Contract vs Capacity Summary" compared to Stats Focus */
  #contractSummaryCard .subtle{
    font-size: 13.5px;
  }

  /* Make Stats Focus card a bit calmer */
  #statsFocusCard{
    border:1px solid rgba(255,255,255,.10);
    background: rgba(11,31,58,.75);
  }

  /* Utility if you use these IDs in Part 1 */
  #wbOperatorsSum, #wbConstraint, #wbNextConstraint{
    font-weight: 900;
  }
</style>
